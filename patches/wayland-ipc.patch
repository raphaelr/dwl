--- a/Makefile
+++ b/Makefile
@@ -55,6 +55,18 @@ idle-protocol.c:
 
 idle-protocol.o: idle-protocol.h
 
+net-tapesoftware-dwl-wm-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/net-tapesoftware-dwl-wm-unstable-v1.xml $@
+
+net-tapesoftware-dwl-wm-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/net-tapesoftware-dwl-wm-unstable-v1.xml $@
+
+net-tapesoftware-dwl-wm-unstable-v1-protocol.o: net-tapesoftware-dwl-wm-unstable-v1-protocol.h
+dwl.o: net-tapesoftware-dwl-wm-unstable-v1-protocol.h
+dwl: net-tapesoftware-dwl-wm-unstable-v1-protocol.o
+
 config.h: | config.def.h
 	cp config.def.h $@
 
--- a/dwl.c
+++ b/dwl.c
@@ -46,6 +46,7 @@
 #include <wlr/backend/libinput.h>
 #include <wlr/util/log.h>
 #include <xkbcommon/xkbcommon.h>
+#include "net-tapesoftware-dwl-wm-unstable-v1-protocol.h"
 #ifdef XWAYLAND
 #include <X11/Xlib.h>
 #include <wlr/xwayland.h>
@@ -166,8 +167,15 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+typedef struct {
+    struct wl_list link;
+    struct wl_resource *resource;
+    struct Monitor *monitor;
+} DwlWmMonitor;
+
 struct Monitor {
 	struct wl_list link;
+    struct wl_list dwl_wm_monitor_link;
 	struct wlr_output *wlr_output;
 	struct wl_listener frame;
 	struct wl_listener destroy;
@@ -304,6 +312,11 @@ static struct wlr_surface *xytolayersurf
 static Monitor *xytomon(double x, double y);
 static void zoom(const Arg *arg);
 
+static void dwl_wm_bind(struct wl_client *client, void *data,
+        uint32_t version, uint32_t id);
+static void dwl_wm_set_monitor_inert(Monitor *monitor);
+static void dwl_wm_printstatus(Monitor *monitor);
+
 /* variables */
 static const char broken[] = "broken";
 static struct wl_display *dpy;
@@ -726,6 +739,7 @@ cleanupmon(struct wl_listener *listener,
 	wl_list_remove(&m->frame.link);
 	wl_list_remove(&m->link);
 	wlr_output_layout_remove(output_layout, m->wlr_output);
+    dwl_wm_set_monitor_inert(m);
 
 	nmons = wl_list_length(&mons);
 	do // don't switch to disabled mons
@@ -820,6 +834,7 @@ createmon(struct wl_listener *listener,
 	struct wlr_output *wlr_output = data;
 	const MonitorRule *r;
 	Monitor *m = wlr_output->data = calloc(1, sizeof(*m));
+    wl_list_init(&m->dwl_wm_monitor_link);
 	m->wlr_output = wlr_output;
 
 	/* Initialize monitor state using configured rules */
@@ -1584,6 +1599,7 @@ printstatus(void)
 		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, m->tagset[m->seltags],
 				sel, urg);
 		printf("%s layout %s\n", m->wlr_output->name, m->lt[m->sellt]->symbol);
+        dwl_wm_printstatus(m);
 	}
 	fflush(stdout);
 }
@@ -2125,6 +2141,7 @@ setup(void)
 	wl_signal_add(&output_mgr->events.test, &output_mgr_test);
 
 	presentation = wlr_presentation_create(dpy, backend);
+    wl_global_create(dpy, &znet_tapesoftware_dwl_wm_v1_interface, 1, NULL, dwl_wm_bind);
 
 #ifdef XWAYLAND
 	/*
@@ -2622,3 +2639,156 @@ main(int argc, char *argv[])
 usage:
 	BARF("Usage: %s [-s startup command]", argv[0]);
 }
+
+// dwl_wm_monitor
+static void dwl_wm_set_monitor_inert(Monitor *m)
+{
+    DwlWmMonitor *mon, *montmp;
+    wl_list_for_each_safe(mon, montmp, &m->dwl_wm_monitor_link, link) {
+        wl_resource_set_user_data(mon->resource, NULL);
+        free(mon);
+    }
+}
+static void dwl_wm_monitor_handle_release(struct wl_client *client, struct wl_resource *resource)
+{
+    wl_resource_destroy(resource);
+}
+static void dwl_wm_monitor_handle_destroy(struct wl_resource *resource)
+{
+    DwlWmMonitor *mon = wl_resource_get_user_data(resource);
+    if (mon) {
+        wl_list_remove(&mon->link);
+        free(mon);
+    }
+}
+static void dwl_wm_printstatus_to(Monitor *m, const DwlWmMonitor *mon)
+{
+    Client *c, *focused;
+    int tagmask, state, numclients, focused_client;
+    focused = focustop(m);
+    znet_tapesoftware_dwl_wm_monitor_v1_send_selected(mon->resource, m == selmon);
+
+    for (int tag = 0; tag<LENGTH(tags); tag++) {
+        numclients = state = 0;
+        focused_client = -1;
+        tagmask = 1 << tag;
+        if ((tagmask & m->tagset[m->seltags]) != 0)
+            state = state | ZNET_TAPESOFTWARE_DWL_WM_MONITOR_V1_TAG_STATE_ACTIVE;
+        wl_list_for_each(c, &clients, link) {
+            if (c->mon != m)
+                continue;
+            if (!(c->tags & tagmask))
+                continue;
+            if (c == focused)
+                focused_client = numclients;
+            numclients++;
+            if (c->isurgent)
+                state = state | ZNET_TAPESOFTWARE_DWL_WM_MONITOR_V1_TAG_STATE_URGENT;
+        }
+        znet_tapesoftware_dwl_wm_monitor_v1_send_tag(mon->resource,
+            tag, state, numclients, focused_client);
+    }
+    znet_tapesoftware_dwl_wm_monitor_v1_send_layout(mon->resource, m->lt[m->sellt] - layouts);
+    znet_tapesoftware_dwl_wm_monitor_v1_send_title(mon->resource, focused ? client_get_title(focused) : "");
+    znet_tapesoftware_dwl_wm_monitor_v1_send_frame(mon->resource);
+}
+static void dwl_wm_printstatus(Monitor *m)
+{
+    DwlWmMonitor *mon;
+    wl_list_for_each(mon, &m->dwl_wm_monitor_link, link) {
+        dwl_wm_printstatus_to(m, mon);
+    }
+}
+static void dwl_wm_monitor_handle_set_tags(struct wl_client *client, struct wl_resource *resource, uint32_t t, uint32_t toggle_tagset)
+{
+    DwlWmMonitor *mon;
+    Monitor *m;
+    mon = wl_resource_get_user_data(resource);
+    if (!mon)
+        return;
+    m = mon->monitor;
+	if ((t & TAGMASK) == m->tagset[m->seltags])
+		return;
+    if (toggle_tagset)
+	    m->seltags ^= 1;
+	if (t & TAGMASK)
+		m->tagset[m->seltags] = t & TAGMASK;
+	focusclient(focustop(m), 1);
+	arrange(m);
+	printstatus();
+}
+static void dwl_wm_monitor_handle_set_layout(struct wl_client *client, struct wl_resource *resource, uint32_t layout)
+{
+    DwlWmMonitor *mon;
+    Monitor *m;
+    mon = wl_resource_get_user_data(resource);
+    if (!mon)
+    return;
+    m = mon->monitor;
+    if (layout >= LENGTH(layouts))
+    return;
+
+    if (layout != m->lt[m->sellt] - layouts)
+    m->sellt ^= 1;
+    m->lt[m->sellt] = &layouts[layout];
+    arrange(m);
+    printstatus();
+}
+static const struct znet_tapesoftware_dwl_wm_monitor_v1_interface dwl_wm_monitor_implementation = {
+    .release = dwl_wm_monitor_handle_release,
+    .set_tags = dwl_wm_monitor_handle_set_tags,
+    .set_layout = dwl_wm_monitor_handle_set_layout,
+};
+
+// dwl_wm
+static void dwl_wm_handle_release(struct wl_client *client, struct wl_resource *resource)
+{
+    wl_resource_destroy(resource);
+}
+static void dwl_wm_handle_get_monitor(struct wl_client *client, struct wl_resource *resource,
+        uint32_t id, struct wl_resource *output)
+{
+    DwlWmMonitor *dwl_wm_monitor;
+    struct wlr_output *wlr_output = wlr_output_from_resource(output);
+    struct Monitor *m = wlr_output->data;
+    struct wl_resource *dwlOutputResource = wl_resource_create(client,
+        &znet_tapesoftware_dwl_wm_monitor_v1_interface, wl_resource_get_version(resource), id);
+    if (!resource) {
+        wl_client_post_no_memory(client);
+        return;
+    }
+    dwl_wm_monitor = calloc(1, sizeof(DwlWmMonitor));
+    dwl_wm_monitor->resource = dwlOutputResource;
+    dwl_wm_monitor->monitor = m;
+    wl_resource_set_implementation(dwlOutputResource, &dwl_wm_monitor_implementation,
+        dwl_wm_monitor, dwl_wm_monitor_handle_destroy);
+    wl_list_insert(&m->dwl_wm_monitor_link, &dwl_wm_monitor->link);
+    dwl_wm_printstatus_to(m, dwl_wm_monitor);
+}
+static void dwl_wm_handle_destroy(struct wl_resource *resource)
+{
+}
+static const struct znet_tapesoftware_dwl_wm_v1_interface dwl_wm_implementation = {
+    .release = dwl_wm_handle_release,
+    .get_monitor = dwl_wm_handle_get_monitor,
+};
+
+static void dwl_wm_bind(struct wl_client *client, void *data,
+        uint32_t version, uint32_t id)
+{
+	struct wl_resource *resource = wl_resource_create(client,
+		&znet_tapesoftware_dwl_wm_v1_interface, version, id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	wl_resource_set_implementation(resource, &dwl_wm_implementation, NULL, dwl_wm_handle_destroy);
+
+    for (int i = 0; i < LENGTH(tags); i++) {
+        znet_tapesoftware_dwl_wm_v1_send_tag(resource, tags[i]);
+    }
+    for (int i = 0; i < LENGTH(layouts); i++) {
+        znet_tapesoftware_dwl_wm_v1_send_layout(resource, layouts[i].symbol);
+    }
+}
--- /dev/null
+++ b/protocols/net-tapesoftware-dwl-wm-unstable-v1.xml
@@ -0,0 +1,120 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="net_tapesoftware_dwl_wm_unstable_v1">
+    <copyright>
+        Copyright Â© 2021 Raphael Robatsch
+
+        Permission to use, copy, modify, distribute, and sell this
+        software and its documentation for any purpose is hereby granted
+        without fee, provided that the above copyright notice appear in
+        all copies and that both that copyright notice and this permission
+        notice appear in supporting documentation, and that the name of
+        the copyright holders not be used in advertising or publicity
+        pertaining to distribution of the software without specific,
+        written prior permission.  The copyright holders make no
+        representations about the suitability of this software for any
+        purpose.  It is provided "as is" without express or implied
+        warranty.
+
+        THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+        SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+        FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+        SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+        WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+        AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+        ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+        THIS SOFTWARE.
+    </copyright>
+
+    <interface name="znet_tapesoftware_dwl_wm_v1" version="1">
+        <description summary="control the dwl state">
+            Clients can use this protcol to receive updates of the window manager
+            state (active tags, active layout, and focused window).
+            Clients can also control this state.
+        </description>
+
+        <request name="release" type="destructor">
+            <description summary="release dwl_wm">
+            </description>
+        </request>
+
+        <request name="get_monitor">
+            <description summary="gets a dwl monitor from an output">
+            </description>
+            <arg name="id" type="new_id" interface="znet_tapesoftware_dwl_wm_monitor_v1" />
+            <arg name="output" type="object" interface="wl_output" />
+        </request>
+
+        <event name="tag">
+            <description summary="announces the presence of a tag">
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+
+        <event name="layout">
+            <description summary="announces the presence of a layout">
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+    </interface>
+
+    <interface name="znet_tapesoftware_dwl_wm_monitor_v1" version="1">
+        <description summary="control one monitor">
+        </description>
+
+        <enum name="tag_state">
+          <entry name="none" value="0" summary="no state"/>
+          <entry name="active" value="1" summary="tag is active"/>
+          <entry name="urgent" value="2" summary="tag has at least one urgent client"/>
+        </enum>
+
+        <request name="release" type="destructor">
+            <description summary="release dwl_monitor">
+            </description>
+        </request>
+
+        <event name="selected">
+            <description summary="updates the selected state of the monitor">
+            </description>
+            <arg name="selected" type="uint"/>
+        </event>
+
+        <event name="tag">
+            <description summary="updates the state of one tag">
+            </description>
+            <arg name="tag" type="uint"/>
+            <arg name="state" type="uint" enum="tag_state"/>
+            <arg name="num_clients" type="uint"/>
+            <arg name="focused_client" type="int" summary="-1 if there is no focused client"/>
+        </event>
+
+        <event name="layout">
+            <description summary="updates the selected layout">
+            </description>
+            <arg name="layout" type="uint"/>
+        </event>
+
+        <event name="title">
+            <description summary="updates the focused client">
+            </description>
+            <arg name="title" type="string"/>
+        </event>
+
+        <event name="frame">
+            <description summary="sent after all other events have been sent. allows for atomic updates.">
+            </description>
+        </event>
+
+        <request name="set_tags">
+            <description summary="sets the active tags on this monitor. changes are applied immediately.">
+            </description>
+            <arg name="tagmask" type="uint"/>
+            <arg name="toggle_tagset" type="uint"/>
+        </request>
+
+        <request name="set_layout">
+            <description summary="sets the active layout on this monitor. changes are applied immediately.">
+            </description>
+            <arg name="layout" type="uint"/>
+        </request>
+    </interface>
+</protocol>
