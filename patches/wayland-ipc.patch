--- a/Makefile
+++ b/Makefile
@@ -55,6 +55,18 @@ idle-protocol.c:
 
 idle-protocol.o: idle-protocol.h
 
+net-tapesoftware-dwl-wm-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/net-tapesoftware-dwl-wm-unstable-v1.xml $@
+
+net-tapesoftware-dwl-wm-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/net-tapesoftware-dwl-wm-unstable-v1.xml $@
+
+net-tapesoftware-dwl-wm-unstable-v1-protocol.o: net-tapesoftware-dwl-wm-unstable-v1-protocol.h
+dwl.o: net-tapesoftware-dwl-wm-unstable-v1-protocol.h
+dwl: net-tapesoftware-dwl-wm-unstable-v1-protocol.o
+
 config.h: | config.def.h
 	cp config.def.h $@
 
--- a/dwl.c
+++ b/dwl.c
@@ -46,6 +46,7 @@
 #include <wlr/backend/libinput.h>
 #include <wlr/util/log.h>
 #include <xkbcommon/xkbcommon.h>
+#include "net-tapesoftware-dwl-wm-unstable-v1-protocol.h"
 #ifdef XWAYLAND
 #include <X11/Xlib.h>
 #include <wlr/xwayland.h>
@@ -166,8 +167,14 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+typedef struct {
+    struct wl_list link;
+    struct wl_resource *resource;
+} MonitorStatusListener;
+
 struct Monitor {
 	struct wl_list link;
+    struct wl_list status_link;
 	struct wlr_output *wlr_output;
 	struct wl_listener frame;
 	struct wl_listener destroy;
@@ -304,6 +311,9 @@ static struct wlr_surface *xytolayersurf
 static Monitor *xytomon(double x, double y);
 static void zoom(const Arg *arg);
 
+static void dwl_wm_bind(struct wl_client *client, void *data,
+        uint32_t version, uint32_t id);
+
 /* variables */
 static const char broken[] = "broken";
 static struct wl_display *dpy;
@@ -820,6 +830,7 @@ createmon(struct wl_listener *listener,
 	struct wlr_output *wlr_output = data;
 	const MonitorRule *r;
 	Monitor *m = wlr_output->data = calloc(1, sizeof(*m));
+    wl_list_init(&m->status_link);
 	m->wlr_output = wlr_output;
 
 	/* Initialize monitor state using configured rules */
@@ -1560,8 +1571,9 @@ void
 printstatus(void)
 {
 	Monitor *m = NULL;
+    MonitorStatusListener *status_listener = NULL;
 	Client *c;
-	unsigned int occ, urg, sel;
+	unsigned int occ, urg, sel, active;
 
 	wl_list_for_each(m, &mons, link) {
 		occ = urg = 0;
@@ -1580,8 +1592,16 @@ printstatus(void)
 			sel = 0;
 		}
 
+        active = m->tagset[m->seltags];
+        wl_list_for_each(status_listener, &m->status_link, link) {
+            for (int tag = 0; tag < LENGTH(tags); tag++) {
+                znet_tapesoftware_dwl_wm_monitor_v1_send_tag(status_listener->resource,
+                    tag, (active & (1<<tag)) != 0, (occ & (1<<tag)) != 0);
+            }
+        }
+
 		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
-		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, m->tagset[m->seltags],
+		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, active,
 				sel, urg);
 		printf("%s layout %s\n", m->wlr_output->name, m->lt[m->sellt]->symbol);
 	}
@@ -2125,6 +2145,7 @@ setup(void)
 	wl_signal_add(&output_mgr->events.test, &output_mgr_test);
 
 	presentation = wlr_presentation_create(dpy, backend);
+    wl_global_create(dpy, &znet_tapesoftware_dwl_wm_v1_interface, 1, NULL, dwl_wm_bind);
 
 #ifdef XWAYLAND
 	/*
@@ -2622,3 +2643,70 @@ main(int argc, char *argv[])
 usage:
 	BARF("Usage: %s [-s startup command]", argv[0]);
 }
+
+// dwl_wm_monitor
+static void dwl_wm_monitor_handle_release(struct wl_client *client, struct wl_resource *resource)
+{
+    wl_resource_destroy(resource);
+}
+static void dwl_wm_monitor_handle_destroy(struct wl_resource *resource)
+{
+    MonitorStatusListener *status_listener = wl_resource_get_user_data(resource);
+    wl_list_remove(&status_listener->link);
+    free(status_listener);
+}
+static const struct znet_tapesoftware_dwl_wm_monitor_v1_interface dwl_wm_monitor_implementation = {
+    .release = dwl_wm_monitor_handle_release,
+};
+
+// dwl_wm
+static void dwl_wm_handle_release(struct wl_client *client, struct wl_resource *resource)
+{
+    wl_resource_destroy(resource);
+}
+static void dwl_wm_handle_get_monitor(struct wl_client *client, struct wl_resource *resource,
+        uint32_t id, struct wl_resource *output)
+{
+    struct wlr_output *wlr_output = wlr_output_from_resource(output);
+    Monitor *m;
+    MonitorStatusListener *status_listener;
+    wl_list_for_each(m, &mons, link) {
+        if (m->wlr_output == wlr_output) {
+            struct wl_resource *dwlOutputResource = wl_resource_create(client,
+                &znet_tapesoftware_dwl_wm_monitor_v1_interface, wl_resource_get_version(resource), id);
+            if (!resource) {
+                wl_client_post_no_memory(client);
+                return;
+            }
+            status_listener = calloc(1, sizeof(MonitorStatusListener));
+            status_listener->resource = resource;
+            wl_resource_set_implementation(resource, &dwl_wm_monitor_implementation,
+                status_listener, dwl_wm_monitor_handle_destroy);
+            wl_list_insert(&m->status_link, &status_listener->link);
+        }
+    }
+}
+static void dwl_wm_handle_destroy(struct wl_resource *resource)
+{
+}
+static const struct znet_tapesoftware_dwl_wm_v1_interface dwl_wm_implementation = {
+    .release = dwl_wm_handle_release,
+    .get_monitor = dwl_wm_handle_get_monitor,
+};
+
+static void dwl_wm_bind(struct wl_client *client, void *data,
+        uint32_t version, uint32_t id)
+{
+	struct wl_resource *resource = wl_resource_create(client,
+		&znet_tapesoftware_dwl_wm_v1_interface, version, id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	wl_resource_set_implementation(resource, &dwl_wm_implementation, NULL, dwl_wm_handle_destroy);
+
+    for (int i = 0; i < sizeof(tags)/sizeof(tags[0]); i++) {
+        znet_tapesoftware_dwl_wm_v1_send_tag(resource, tags[i]);
+    }
+}
