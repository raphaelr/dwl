Fix segfault in cleanupmon

I think the loop in cleanupmon is wrong, but I don't have a viable
multihead setup at the moment to test this further.
--- a/dwl.c
+++ b/dwl.c
@@ -716,17 +716,17 @@ cleanupmon(struct wl_listener *listener,
 {
 	struct wlr_output *wlr_output = data;
 	Monitor *m = wlr_output->data;
-	int nmons, i = 0;
+	int i = 0;
 
 	wl_list_remove(&m->destroy.link);
 	wl_list_remove(&m->frame.link);
 	wl_list_remove(&m->link);
 	wlr_output_layout_remove(output_layout, m->wlr_output);
 
-	nmons = wl_list_length(&mons);
-	do // don't switch to disabled mons
-		selmon = wl_container_of(mons.prev, selmon, link);
-	while (!selmon->wlr_output->enabled && i++ < nmons);
+	wl_list_for_each(selmon, &mons, link) {
+		if (selmon->wlr_output->enabled)
+			break;
+	}
 	focusclient(focustop(selmon), 1);
 	closemon(m);
 	free(m);
